1.View.Post();
源码：
public boolean post(Runnable action) {
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }

    // Postpone the runnable until we know on which thread it needs to run.
    // Assume that the runnable will be successfully placed after attach.
    getRunQueue().post(action);
    return true;
}

关键点：attachInfo是否是null
attachInfo 在dispatchAttachedToWindow时赋值
当View的mAttachInfo!=null时也说明肯定完成过UI绘制。


Activity生命周期启动流程

1、ApplicationThread收到AMS的scheduleLaunchActivity
在scheduleLaunchActivity发送
sendMessage(H.LAUNCH_ACTIVITY, r);
2、ActivityThread中的mH（Handler)处理message
调用handleLaunchActivity(r, null);
调用activity的生命周期attach、onCreate、onStart、onResume
3、handleResumeActivity(）
01)
performResumeActivity(token, clearHide){
    r.activity.performResume()
}
02)
wm.addView(decor, l);
4、WindowManagerGlobal调用addView
root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView)
5、addView调用ViewRootImpl.setView
setView{
    requestLayout();
}
requestLayout(){
    scheduleTraversals();
}
scheduleTraversals() {
         //一个刷新周期只执行一次即可，屏蔽其他的刷新请求
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //设置同步障碍Message
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            //屏幕刷新信号VSYNC 监听回调把mTraversalRunnable（执行doTraversal()）
            //push到主线程了且是个异步Message会优先得到执行 ，具体看下Choreographer的实现
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
}


//关键 同步障碍消息
final TraversalRunnable mTraversalRunnable = new TraversalRunnable();
final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
}
doTraversal{
    //移除同步障碍Message
    mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
     //真正执行decorView的绘制
     performTraversals();
}

performTraversals{
    if (mFirst) {
        //performTraversals 第一次调用时候decorView dispatch mAttachInfo变量
        host.dispatchAttachedToWindow(mAttachInfo, 0);
    }
    perforMeasure()
    perforLayout()
    perforDraw()
    mFirst=false;
}

6.ViewGroup中dispatchAttachedToWindow
01）
dispatchAttachedToWindow{
    if (mRunQueue != null) {
         mRunQueue.executeActions(info.mHandler);
         mRunQueue = null;
    }
    onAttachedToWindow();
}

